'use strict';

/* eslint func-names: off */
require('./polyfills');

const fs = require('fs');
const http = require('http');
const path = require('path');
const url = require('url');
const chokidar = require('chokidar');
const compress = require('compression');
const del = require('del');
const express = require('express');
const httpProxyMiddleware = require('http-proxy-middleware');
const ip = require('ip');
const killable = require('killable');
const serveIndex = require('serve-index');
const historyApiFallback = require('connect-history-api-fallback');
const selfsigned = require('selfsigned');
const sockjs = require('sockjs');
const spdy = require('spdy');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');
const createLog = require('./createLog');
const OptionsValidationError = require('./OptionsValidationError');
const optionsSchema = require('./optionsSchema.json');

const clientStats = { all: false, assets: true, warnings: true, errors: true, errorDetails: false, hash: true };

function Server(compiler, options, _log) {
  // Default options
  if (!options) options = {};
  this.log = _log || createLog(options);

  const validationErrors = webpack.validateSchema(optionsSchema, options);
  if (validationErrors.length) {
    throw new OptionsValidationError(validationErrors);
  }

  if (options.lazy && !options.filename) {
    throw new Error("'filename' option must be set in lazy mode.");
  }

  this.hot = options.hot || options.hotOnly;
  this.headers = options.headers;
  this.clientLogLevel = options.clientLogLevel;
  this.clientOverlay = options.overlay;
  this.progress = options.progress;
  this.disableHostCheck = !!options.disableHostCheck;
  this.publicHost = options.public;
  this.allowedHosts = options.allowedHosts;
  this.sockets = [];
  this.contentBaseWatchers = [];
  this.watchOptions = options.watchOptions || {};

  // Listening for events
  const invalidPlugin = () => {
    this.sockWrite(this.sockets, 'invalid');
  };
  if (this.progress) {
    const progressPlugin = new webpack.ProgressPlugin((percent, msg, addInfo) => {
      percent = Math.floor(percent * 100);
      if (percent === 100) msg = 'Compilation completed';
      if (addInfo) msg = `${msg} (${addInfo})`;
      this.sockWrite(this.sockets, 'progress-update', { percent, msg });
    });
    progressPlugin.apply(compiler);
  }

  const addCompilerHooks = (comp) => {
    comp.hooks.compile.tap('webpack-dev-server', invalidPlugin);
    comp.hooks.invalid.tap('webpack-dev-server', invalidPlugin);
    comp.hooks.done.tap('webpack-dev-server', (stats) => {
      this._sendStats(this.sockets, stats.toJson(clientStats));
      this._stats = stats;
    });
  };
  if (compiler.compilers) {
    compiler.compilers.forEach(addCompilerHooks);
  } else {
    addCompilerHooks(compiler);
  }

  // Init express server
  const app = this.app = new express(); // eslint-disable-line

  app.all('*', (req, res, next) => { // eslint-disable-line
    if (this.checkHost(req.headers)) { return next(); }
    res.send('Invalid Host header');
  });

  const wdmOptions = { logLevel: this.log.options.level };

  // middleware for serving webpack bundle
  this.middleware = webpackDevMiddleware(compiler, Object.assign({}, options, wdmOptions));

  app.get('/__webpack_dev_server__/live.bundle.js', (req, res) => {
    res.setHeader('Content-Type', 'application/javascript');
    fs.createReadStream(path.join(__dirname, '..', 'client', 'live.bundle.js')).pipe(res);
  });

  app.get('/__webpack_dev_server__/sockjs.bundle.js', (req, res) => {
    res.setHeader('Content-Type', 'application/javascript');
    fs.createReadStream(path.join(__dirname, '..', 'client', 'sockjs.bundle.js')).pipe(res);
  });

  app.get('/webpack-dev-server.js', (req, res) => {
    res.setHeader('Content-Type', 'application/javascript');
    fs.createReadStream(path.join(__dirname, '..', 'client', 'index.bundle.js')).pipe(res);
  });

  app.get('/webpack-dev-server/*', (req, res) => {
    res.setHeader('Content-Type', 'text/html');
    fs.createReadStream(path.join(__dirname, '..', 'client', 'live.html')).pipe(res);
  });

  app.get('/webpack-dev-server', (req, res) => {
    res.setHeader('Content-Type', 'text/html');
    res.write('<!DOCTYPE html><html><head><meta charset="utf-8"/></head><body>');
    const outputPath = this.middleware.getFilenameFromUrl(options.publicPath || '/');
    const filesystem = this.middleware.fileSystem;

    function writeDirectory(baseUrl, basePath) {
      const content = filesystem.readdirSync(basePath);
      res.write('<ul>');
      content.forEach((item) => {
        const p = `${basePath}/${item}`;
        if (filesystem.statSync(p).isFile()) {
          res.write('<li><a href="');
          res.write(baseUrl + item);
          res.write('">');
          res.write(item);
          res.write('</a></li>');
          if (/\.js$/.test(item)) {
            const htmlItem = item.substr(0, item.length - 3);
            res.write('<li><a href="');
            res.write(baseUrl + htmlItem);
            res.write('">');
            res.write(htmlItem);
            res.write('</a> (magic html for ');
            res.write(item);
            res.write(') (<a href="');
            res.write(baseUrl.replace(/(^(https?:\/\/[^\/]+)?\/)/, "$1webpack-dev-server/") + htmlItem); // eslint-disable-line
            res.write('">webpack-dev-server</a>)</li>');
          }
        } else {
          res.write('<li>');
          res.write(item);
          res.write('<br>');
          writeDirectory(`${baseUrl + item}/`, p);
          res.write('</li>');
        }
      });
      res.write('</ul>');
    }
    writeDirectory(options.publicPath || '/', outputPath);
    res.end('</body></html>');
  });

  let contentBase;
  if (options.contentBase !== undefined) { // eslint-disable-line
    contentBase = options.contentBase; // eslint-disable-line
  } else {
    contentBase = process.cwd();
  }

  // Keep track of websocket proxies for external websocket upgrade.
  const websocketProxies = [];

  const features = {
    compress() {
      if (options.compress) {
        // Enable gzip compression.
        app.use(compress());
      }
    },

    proxy() {
      if (options.proxy) {
        /**
          * Assume a proxy configuration specified as:
          * proxy: {
          *   'context': { options }
          * }
          * OR
          * proxy: {
          *   'context': 'target'
          * }
          */
        if (!Array.isArray(options.proxy)) {
          options.proxy = Object.keys(options.proxy).map((context) => {
            let proxyOptions;
            // For backwards compatibility reasons.
            const correctedContext = context.replace(/^\*$/, '**').replace(/\/\*$/, '');

            if (typeof options.proxy[context] === 'string') {
              proxyOptions = {
                context: correctedContext,
                target: options.proxy[context]
              };
            } else {
              proxyOptions = Object.assign({}, options.proxy[context]);
              proxyOptions.context = correctedContext;
            }
            proxyOptions.logLevel = proxyOptions.logLevel || 'warn';

            return proxyOptions;
          });
        }

        const getProxyMiddleware = (proxyConfig) => {
          const context = proxyConfig.context || proxyConfig.path;

          // It is possible to use the `bypass` method without a `target`.
          // However, the proxy middleware has no use in this case, and will fail to instantiate.
          if (proxyConfig.target) {
            return httpProxyMiddleware(context, proxyConfig);
          }
        };

        /**
        * Assume a proxy configuration specified as:
        * proxy: [
        *   {
        *     context: ...,
        *     ...options...
        *   },
        *   // or:
        *   function() {
        *     return {
        *       context: ...,
        *       ...options...
        *     };
        *   }
        * ]
        */
        options.proxy.forEach((proxyConfigOrCallback) => {
          let proxyConfig;
          let proxyMiddleware;

          if (typeof proxyConfigOrCallback === 'function') {
            proxyConfig = proxyConfigOrCallback();
          } else {
            proxyConfig = proxyConfigOrCallback;
          }

          proxyMiddleware = getProxyMiddleware(proxyConfig);
          if (proxyConfig.ws) {
            websocketProxies.push(proxyMiddleware);
          }

          app.use((req, res, next) => {
            if (typeof proxyConfigOrCallback === 'function') {
              const newProxyConfig = proxyConfigOrCallback();
              if (newProxyConfig !== proxyConfig) {
                proxyConfig = newProxyConfig;
                proxyMiddleware = getProxyMiddleware(proxyConfig);
              }
            }
            const bypass = typeof proxyConfig.bypass === 'function';
            // eslint-disable-next-line
            const bypassUrl = bypass && proxyConfig.bypass(req, res, proxyConfig) || false;

            if (bypassUrl) {
              req.url = bypassUrl;
              next();
            } else if (proxyMiddleware) {
              return proxyMiddleware(req, res, next);
            } else {
              next();
            }
          });
        });
      }
    },

    historyApiFallback() {
      if (options.historyApiFallback) {
        // Fall back to /index.html if nothing else matches.
        app.use(historyApiFallback(typeof options.historyApiFallback === 'object' ? options.historyApiFallback : null));
      }
    },

    contentBaseFiles: () => {
      if (Array.isArray(contentBase)) {
        contentBase.forEach((item) => {
          app.get('*', express.static(item));
        });
      } else if (/^(https?:)?\/\//.test(contentBase)) {
        this.log.warn('Using a URL as contentBase is deprecated and will be removed in the next major version. Please use the proxy option instead.');
        this.log.warn('proxy: {\n\t"*": "<your current contentBase configuration>"\n}'); // eslint-disable-line quotes
        // Redirect every request to contentBase
        app.get('*', (req, res) => {
          res.writeHead(302, {
            Location: contentBase + req.path + (req._parsedUrl.search || '')
          });
          res.end();
        });
      } else if (typeof contentBase === 'number') {
        this.log.warn('Using a number as contentBase is deprecated and will be removed in the next major version. Please use the proxy option instead.');
        this.log.warn('proxy: {\n\t"*": "//localhost:<your current contentBase configuration>"\n}'); // eslint-disable-line quotes
        // Redirect every request to the port contentBase
        app.get('*', (req, res) => {
          res.writeHead(302, {
            Location: `//localhost:${contentBase}${req.path}${req._parsedUrl.search || ''}`
          });
          res.end();
        });
      } else {
        // route content request
        app.get('*', express.static(contentBase, options.staticOptions));
      }
    },

    contentBaseIndex() {
      if (Array.isArray(contentBase)) {
        contentBase.forEach((item) => {
          app.get('*', serveIndex(item));
        });
      } else if (!/^(https?:)?\/\//.test(contentBase) && typeof contentBase !== 'number') {
        app.get('*', serveIndex(contentBase));
      }
    },

    watchContentBase: () => {
      if (/^(https?:)?\/\//.test(contentBase) || typeof contentBase === 'number') {
        throw new Error('Watching remote files is not supported.');
      } else if (Array.isArray(contentBase)) {
        contentBase.forEach((item) => {
          this._watch(item);
        });
      } else {
        this._watch(contentBase);
      }
    },

    before: () => {
      if (typeof options.before === 'function') {
        options.before(app, this);
      }
    },

    middleware: () => {
      // include our middleware to ensure it is able to handle '/index.html' request after redirect
      app.use(this.middleware);
    },

    after: () => {
      if (typeof options.after === 'function') { options.after(app, this); }
    },

    headers: () => {
      app.all('*', this.setContentHeaders.bind(this));
    },

    magicHtml: () => {
      app.get('*', this.serveMagicHtml.bind(this));
    },

    setup: () => {
      if (typeof options.setup === 'function') {
        this.log.warn('The `setup` option is deprecated and will be removed in v3. Please update your config to use `before`');
        options.setup(app, this);
      }
    }
  };

  const defaultFeatures = ['before', 'setup', 'headers', 'middleware'];
  if (options.proxy) { defaultFeatures.push('proxy', 'middleware'); }
  if (contentBase !== false) { defaultFeatures.push('contentBaseFiles'); }
  if (options.watchContentBase) { defaultFeatures.push('watchContentBase'); }
  if (options.historyApiFallback) {
    defaultFeatures.push('historyApiFallback', 'middleware');
    if (contentBase !== false) { defaultFeatures.push('contentBaseFiles'); }
  }
  defaultFeatures.push('magicHtml');
  if (contentBase !== false) { defaultFeatures.push('contentBaseIndex'); }
  // compress is placed last and uses unshift so that it will be the first middleware used
  if (options.compress) { defaultFeatures.unshift('compress'); }
  if (options.after) { defaultFeatures.push('after'); }

  (options.features || defaultFeatures).forEach((feature) => {
    features[feature]();
  });

  if (options.https) {
    // for keep supporting CLI parameters
    if (typeof options.https === 'boolean') {
      options.https = {
        key: options.key,
        cert: options.cert,
        ca: options.ca,
        pfx: options.pfx,
        passphrase: options.pfxPassphrase,
        requestCert: options.requestCert || false
      };
    }

    let fakeCert;
    if (!options.https.key || !options.https.cert) {
      // Use a self-signed certificate if no certificate was configured.
      // Cycle certs every 24 hours
      const certPath = path.join(__dirname, '../ssl/server.pem');
      let certExists = fs.existsSync(certPath);

      if (certExists) {
        const certStat = fs.statSync(certPath);
        const certTtl = 1000 * 60 * 60 * 24;
        const now = new Date();

        // cert is more than 30 days old, kill it with fire
        if ((now - certStat.ctime) / certTtl > 30) {
          this.log.info('SSL Certificate is more than 30 days old. Removing.');
          del.sync([certPath], { force: true });
          certExists = false;
        }
      }

      if (!certExists) {
        this.log.info('Generating SSL Certificate');
        const attrs = [{ name: 'commonName', value: 'localhost' }];
        const pems = selfsigned.generate(attrs, {
          algorithm: 'sha256',
          days: 30,
          keySize: 2048,
