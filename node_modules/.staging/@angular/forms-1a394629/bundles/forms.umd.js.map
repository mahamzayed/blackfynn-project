{"version":3,"file":"forms.umd.js","sources":["../../../../../../../../../execroot/angular/packages/forms/src/directives/abstract_control_directive.ts","../../../../../../../../../../../../../../Users/berchet/Code/angular/node_modules/tslib/tslib.es6.js","../../../../../../../../../execroot/angular/packages/forms/src/directives/control_container.ts","../../../../../../../../../execroot/angular/packages/forms/src/validators.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/control_value_accessor.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/checkbox_value_accessor.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/default_value_accessor.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/normalize_validator.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/number_value_accessor.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/ng_control.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/radio_control_value_accessor.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/range_value_accessor.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/error_examples.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/reactive_errors.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/select_control_value_accessor.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/select_multiple_control_value_accessor.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/shared.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/abstract_form_group_directive.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/ng_control_status.ts","../../../../../../../../../execroot/angular/packages/forms/src/model.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/ng_form.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/template_driven_errors.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/ng_model_group.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/ng_model.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/reactive_directives/form_control_directive.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/reactive_directives/form_group_directive.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/reactive_directives/form_group_name.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/reactive_directives/form_control_name.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/validators.ts","../../../../../../../../../execroot/angular/packages/forms/src/form_builder.ts","../../../../../../../../../execroot/angular/packages/forms/src/version.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives/ng_no_validate_directive.ts","../../../../../../../../../execroot/angular/packages/forms/src/directives.ts","../../../../../../../../../execroot/angular/packages/forms/src/form_providers.ts","../../../../../../../../../execroot/angular/packages/forms/src/forms.ts","../../../../../../../../../execroot/angular/packages/forms/public_api.ts","../../../../../../../../../execroot/angular/packages/forms/index.ts","../../../../../../../../../execroot/angular/packages/forms/forms.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\nimport {AbstractControl} from '../model';\nimport {ValidationErrors} from './validators';\n\n/**\n * Base class for control directives.\n *\n * Only used internally in the forms module.\n *\n *\n */\nexport abstract class AbstractControlDirective {\n  /**\n   * The `FormControl`, `FormGroup`, or `FormArray`\n   * that backs this directive. Most properties fall through to that\n   * instance.\n   */\n  abstract get control(): AbstractControl|null;\n\n  /** The value of the control. */\n  get value(): any { return this.control ? this.control.value : null; }\n\n  /**\n   * A control is `valid` when its `status === VALID`.\n   *\n   * In order to have this status, the control must have passed all its\n   * validation checks.\n   */\n  get valid(): boolean|null { return this.control ? this.control.valid : null; }\n\n  /**\n   * A control is `invalid` when its `status === INVALID`.\n   *\n   * In order to have this status, the control must have failed\n   * at least one of its validation checks.\n   */\n  get invalid(): boolean|null { return this.control ? this.control.invalid : null; }\n\n  /**\n   * A control is `pending` when its `status === PENDING`.\n   *\n   * In order to have this status, the control must be in the\n   * middle of conducting a validation check.\n   */\n  get pending(): boolean|null { return this.control ? this.control.pending : null; }\n\n  /**\n   * A control is `disabled` when its `status === DISABLED`.\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   */\n  get disabled(): boolean|null { return this.control ? this.control.disabled : null; }\n\n  /**\n   * A control is `enabled` as long as its `status !== DISABLED`.\n   *\n   * In other words, it has a status of `VALID`, `INVALID`, or\n   * `PENDING`.\n   */\n  get enabled(): boolean|null { return this.control ? this.control.enabled : null; }\n\n  /**\n   * Returns any errors generated by failing validation. If there\n   * are no errors, it will return null.\n   */\n  get errors(): ValidationErrors|null { return this.control ? this.control.errors : null; }\n\n  /**\n   * A control is `pristine` if the user has not yet changed\n   * the value in the UI.\n   *\n   * Note that programmatic changes to a control's value will\n   * *not* mark it dirty.\n   */\n  get pristine(): boolean|null { return this.control ? this.control.pristine : null; }\n\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * Note that programmatic changes to a control's value will\n   * *not* mark it dirty.\n   */\n  get dirty(): boolean|null { return this.control ? this.control.dirty : null; }\n\n  /**\n   * A control is marked `touched` once the user has triggered\n   * a `blur` event on it.\n   */\n  get touched(): boolean|null { return this.control ? this.control.touched : null; }\n\n  get status(): string|null { return this.control ? this.control.status : null; }\n\n  /**\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   */\n  get untouched(): boolean|null { return this.control ? this.control.untouched : null; }\n\n  /**\n   * Emits an event every time the validation status of the control\n   * is re-calculated.\n   */\n  get statusChanges(): Observable<any>|null {\n    return this.control ? this.control.statusChanges : null;\n  }\n\n  /**\n   * Emits an event every time the value of the control changes, in\n   * the UI or programmatically.\n   */\n  get valueChanges(): Observable<any>|null {\n    return this.control ? this.control.valueChanges : null;\n  }\n\n  /**\n   * Returns an array that represents the path from the top-level form\n   * to this control. Each index is the string name of the control on\n   * that level.\n   */\n  get path(): string[]|null { return null; }\n\n  /**\n   * Resets the form control. This means by default:\n   *\n   * * it is marked as `pristine`\n   * * it is marked as `untouched`\n   * * value is set to null\n   *\n   * For more information, see `AbstractControl`.\n   */\n  reset(value: any = undefined): void {\n    if (this.control) this.control.reset(value);\n  }\n\n  /**\n   * Returns true if the control with the given path has the error specified. Otherwise\n   * returns false.\n   *\n   * If no path is given, it checks for the error on the present control.\n   */\n  hasError(errorCode: string, path?: string[]): boolean {\n    return this.control ? this.control.hasError(errorCode, path) : false;\n  }\n\n  /**\n   * Returns error data if the control with the given path has the error specified. Otherwise\n   * returns null or undefined.\n   *\n   * If no path is given, it checks for the error on the present control.\n   */\n  getError(errorCode: string, path?: string[]): any {\n    return this.control ? this.control.getError(errorCode, path) : null;\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {Form} from './form_interface';\n\n\n/**\n * A directive that contains multiple `NgControl`s.\n *\n * Only used by the forms module.\n *\n *\n */\nexport abstract class ControlContainer extends AbstractControlDirective {\n  name: string;\n\n  /**\n   * Get the form to which this container belongs.\n   */\n  get formDirective(): Form|null { return null; }\n\n  /**\n   * Get the path to this container.\n   */\n  get path(): string[]|null { return null; }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken, ÉµisObservable as isObservable, ÉµisPromise as isPromise} from '@angular/core';\nimport {Observable, forkJoin, from} from 'rxjs';\nimport {map} from 'rxjs/operators';\nimport {AsyncValidatorFn, ValidationErrors, Validator, ValidatorFn} from './directives/validators';\nimport {AbstractControl, FormControl} from './model';\n\nfunction isEmptyInputValue(value: any): boolean {\n  // we don't check for string here so it also works with arrays\n  return value == null || value.length === 0;\n}\n\n/**\n * Providers for validators to be used for `FormControl`s in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * ### Example\n *\n * ```typescript\n * @Directive({\n *   selector: '[custom-validator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return {\"custom\": true};\n *   }\n * }\n * ```\n *\n *\n */\nexport const NG_VALIDATORS = new InjectionToken<Array<Validator|Function>>('NgValidators');\n\n/**\n * Providers for asynchronous validators to be used for `FormControl`s\n * in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * See `NG_VALIDATORS` for more details.\n *\n *\n */\nexport const NG_ASYNC_VALIDATORS =\n    new InjectionToken<Array<Validator|Function>>('NgAsyncValidators');\n\nconst EMAIL_REGEXP =\n    /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n\n/**\n * Provides a set of validators used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns a map of errors. A null map means that validation has passed.\n *\n * ### Example\n *\n * ```typescript\n * var loginControl = new FormControl(\"\", Validators.required)\n * ```\n *\n *\n */\nexport class Validators {\n  /**\n   * Validator that requires controls to have a value greater than a number.\n   *`min()` exists only as a function, not as a directive. For example,\n   * `control = new FormControl('', Validators.min(3));`.\n   */\n  static min(min: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value = parseFloat(control.value);\n      // Controls with NaN values after parsing should be treated as not having a\n      // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n      return !isNaN(value) && value < min ? {'min': {'min': min, 'actual': control.value}} : null;\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value less than a number.\n   * `max()` exists only as a function, not as a directive. For example,\n   * `control = new FormControl('', Validators.max(15));`.\n   */\n  static max(max: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value = parseFloat(control.value);\n      // Controls with NaN values after parsing should be treated as not having a\n      // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n      return !isNaN(value) && value > max ? {'max': {'max': max, 'actual': control.value}} : null;\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a non-empty value.\n   */\n  static required(control: AbstractControl): ValidationErrors|null {\n    return isEmptyInputValue(control.value) ? {'required': true} : null;\n  }\n\n  /**\n   * Validator that requires control value to be true.\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors|null {\n    return control.value === true ? null : {'required': true};\n  }\n\n  /**\n   * Validator that performs email validation.\n   */\n  static email(control: AbstractControl): ValidationErrors|null {\n    if (isEmptyInputValue(control.value)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    return EMAIL_REGEXP.test(control.value) ? null : {'email': true};\n  }\n\n  /**\n   * Validator that requires controls to have a value of a minimum length.\n   */\n  static minLength(minLength: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const length: number = control.value ? control.value.length : 0;\n      return length < minLength ?\n          {'minlength': {'requiredLength': minLength, 'actualLength': length}} :\n          null;\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value of a maximum length.\n   */\n  static maxLength(maxLength: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      const length: number = control.value ? control.value.length : 0;\n      return length > maxLength ?\n          {'maxlength': {'requiredLength': maxLength, 'actualLength': length}} :\n          null;\n    };\n  }\n\n  /**\n   * Validator that requires a control to match a regex to its value.\n   */\n  static pattern(pattern: string|RegExp): ValidatorFn {\n    if (!pattern) return Validators.nullValidator;\n    let regex: RegExp;\n    let regexStr: string;\n    if (typeof pattern === 'string') {\n      regexStr = '';\n\n      if (pattern.charAt(0) !== '^') regexStr += '^';\n\n      regexStr += pattern;\n\n      if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n\n      regex = new RegExp(regexStr);\n    } else {\n      regexStr = pattern.toString();\n      regex = pattern;\n    }\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value: string = control.value;\n      return regex.test(value) ? null :\n                                 {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n    };\n  }\n\n  /**\n   * No-op validator.\n   */\n  static nullValidator(c: AbstractControl): ValidationErrors|null { return null; }\n\n  /**\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps.\n   */\n  static compose(validators: null): null;\n  static compose(validators: (ValidatorFn|null|undefined)[]): ValidatorFn|null;\n  static compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n    if (!validators) return null;\n    const presentValidators: ValidatorFn[] = validators.filter(isPresent) as any;\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      return _mergeErrors(_executeValidators(control, presentValidators));\n    };\n  }\n\n  static composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n    if (!validators) return null;\n    const presentValidators: AsyncValidatorFn[] = validators.filter(isPresent) as any;\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      const observables = _executeAsyncValidators(control, presentValidators).map(toObservable);\n      return forkJoin(observables).pipe(map(_mergeErrors));\n    };\n  }\n}\n\nfunction isPresent(o: any): boolean {\n  return o != null;\n}\n\nexport function toObservable(r: any): Observable<any> {\n  const obs = isPromise(r) ? from(r) : r;\n  if (!(isObservable(obs))) {\n    throw new Error(`Expected validator to return Promise or Observable.`);\n  }\n  return obs;\n}\n\nfunction _executeValidators(control: AbstractControl, validators: ValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _executeAsyncValidators(control: AbstractControl, validators: AsyncValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _mergeErrors(arrayOfErrors: ValidationErrors[]): ValidationErrors|null {\n  const res: {[key: string]: any} =\n      arrayOfErrors.reduce((res: ValidationErrors | null, errors: ValidationErrors | null) => {\n        return errors != null ? {...res !, ...errors} : res !;\n      }, {});\n  return Object.keys(res).length === 0 ? null : res;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * A `ControlValueAccessor` acts as a bridge between the Angular forms API and a\n * native element in the DOM.\n *\n * Implement this interface if you want to create a custom form control directive\n * that integrates with Angular forms.\n *\n *\n */\nexport interface ControlValueAccessor {\n  /**\n   * Writes a new value to the element.\n   *\n   * This method will be called by the forms API to write to the view when programmatic\n   * (model -> view) changes are requested.\n   *\n   * Example implementation of `writeValue`:\n   *\n   * ```ts\n   * writeValue(value: any): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\n   * }\n   * ```\n   */\n  writeValue(obj: any): void;\n\n  /**\n   * Registers a callback function that should be called when the control's value\n   * changes in the UI.\n   *\n   * This is called by the forms API on initialization so it can update the form\n   * model when values propagate from the view (view -> model).\n   *\n   * If you are implementing `registerOnChange` in your own value accessor, you\n   * will typically want to save the given function so your class can call it\n   * at the appropriate time.\n   *\n   * ```ts\n   * registerOnChange(fn: (_: any) => void): void {\n   *   this._onChange = fn;\n   * }\n   * ```\n   *\n   * When the value changes in the UI, your class should call the registered\n   * function to allow the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    (change): '_onChange($event.target.value)'\n   * }\n   * ```\n   *\n   */\n  registerOnChange(fn: any): void;\n\n  /**\n   * Registers a callback function that should be called when the control receives\n   * a blur event.\n   *\n   * This is called by the forms API on initialization so it can update the form model\n   * on blur.\n   *\n   * If you are implementing `registerOnTouched` in your own value accessor, you\n   * will typically want to save the given function so your class can call it\n   * when the control should be considered blurred (a.k.a. \"touched\").\n   *\n   * ```ts\n   * registerOnTouched(fn: any): void {\n   *   this._onTouched = fn;\n   * }\n   * ```\n   *\n   * On blur (or equivalent), your class should call the registered function to allow\n   * the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    '(blur)': '_onTouched()'\n   * }\n   * ```\n   */\n  registerOnTouched(fn: any): void;\n\n  /**\n   * This function is called by the forms API when the control status changes to\n   * or from \"DISABLED\". Depending on the value, it should enable or disable the\n   * appropriate DOM element.\n   *\n   * Example implementation of `setDisabledState`:\n   *\n   * ```ts\n   * setDisabledState(isDisabled: boolean): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n   * }\n   * ```\n   *\n   * @param isDisabled\n   */\n  setDisabledState?(isDisabled: boolean): void;\n}\n\n/**\n * Used to provide a `ControlValueAccessor` for form controls.\n *\n * See `DefaultValueAccessor` for how to implement one.\n *\n */\nexport const NG_VALUE_ACCESSOR = new InjectionToken<ControlValueAccessor>('NgValueAccessor');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, Renderer2, forwardRef} from '@angular/core';\n\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nexport const CHECKBOX_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => CheckboxControlValueAccessor),\n  multi: true,\n};\n\n/**\n * The accessor for writing a value and listening to changes on a checkbox input element.\n *\n *  ### Example\n *  ```\n *  <input type=\"checkbox\" name=\"rememberLogin\" ngModel>\n *  ```\n *\n *\n */\n@Directive({\n  selector:\n      'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',\n  host: {'(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()'},\n  providers: [CHECKBOX_VALUE_ACCESSOR]\n})\nexport class CheckboxControlValueAccessor implements ControlValueAccessor {\n  onChange = (_: any) => {};\n  onTouched = () => {};\n\n  constructor(private _renderer: Renderer2, private _elementRef: ElementRef) {}\n\n  writeValue(value: any): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'checked', value);\n  }\n  registerOnChange(fn: (_: any) => {}): void { this.onChange = fn; }\n  registerOnTouched(fn: () => {}): void { this.onTouched = fn; }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, Inject, InjectionToken, Optional, Renderer2, forwardRef} from '@angular/core';\nimport {ÉµgetDOM as getDOM} from '@angular/platform-browser';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nexport const DEFAULT_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => DefaultValueAccessor),\n  multi: true\n};\n\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\nfunction _isAndroid(): boolean {\n  const userAgent = getDOM() ? getDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\n\n/**\n * Turn this mode on if you want form directives to buffer IME input until compositionend\n * @experimental\n */\nexport const COMPOSITION_BUFFER_MODE = new InjectionToken<boolean>('CompositionEventMode');\n\n/**\n * The default accessor for writing a value and listening to changes that is used by the\n * `NgModel`, `FormControlDirective`, and `FormControlName` directives.\n *\n *  ### Example\n *  ```\n *  <input type=\"text\" name=\"searchQuery\" ngModel>\n *  ```\n *\n *\n */\n@Directive({\n  selector:\n      'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',\n  // TODO: vsavkin replace the above selector with the one below it once\n  // https://github.com/angular/angular/issues/3011 is implemented\n  // selector: '[ngModel],[formControl],[formControlName]',\n  host: {\n    '(input)': '$any(this)._handleInput($event.target.value)',\n    '(blur)': 'onTouched()',\n    '(compositionstart)': '$any(this)._compositionStart()',\n    '(compositionend)': '$any(this)._compositionEnd($event.target.value)'\n  },\n  providers: [DEFAULT_VALUE_ACCESSOR]\n})\nexport class DefaultValueAccessor implements ControlValueAccessor {\n  onChange = (_: any) => {};\n  onTouched = () => {};\n\n  /** Whether the user is creating a composition string (IME events). */\n  private _composing = false;\n\n  constructor(\n      private _renderer: Renderer2, private _elementRef: ElementRef,\n      @Optional() @Inject(COMPOSITION_BUFFER_MODE) private _compositionMode: boolean) {\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid();\n    }\n  }\n\n  writeValue(value: any): void {\n    const normalizedValue = value == null ? '' : value;\n    this._renderer.setProperty(this._elementRef.nativeElement, 'value', normalizedValue);\n  }\n\n  registerOnChange(fn: (_: any) => void): void { this.onChange = fn; }\n  registerOnTouched(fn: () => void): void { this.onTouched = fn; }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  }\n\n  /** @internal */\n  _handleInput(value: any): void {\n    if (!this._compositionMode || (this._compositionMode && !this._composing)) {\n      this.onChange(value);\n    }\n  }\n\n  /** @internal */\n  _compositionStart(): void { this._composing = true; }\n\n  /** @internal */\n  _compositionEnd(value: any): void {\n    this._composing = false;\n    this._compositionMode && this.onChange(value);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractControl} from '../model';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n\nexport function normalizeValidator(validator: ValidatorFn | Validator): ValidatorFn {\n  if ((<Validator>validator).validate) {\n    return (c: AbstractControl) => (<Validator>validator).validate(c);\n  } else {\n    return <ValidatorFn>validator;\n  }\n}\n\nexport function normalizeAsyncValidator(validator: AsyncValidatorFn | AsyncValidator):\n    AsyncValidatorFn {\n  if ((<AsyncValidator>validator).validate) {\n    return (c: AbstractControl) => (<AsyncValidator>validator).validate(c);\n  } else {\n    return <AsyncValidatorFn>validator;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, Renderer2, forwardRef} from '@angular/core';\n\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nexport const NUMBER_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => NumberValueAccessor),\n  multi: true\n};\n\n/**\n * The accessor for writing a number value and listening to changes that is used by the\n * `NgModel`, `FormControlDirective`, and `FormControlName` directives.\n *\n *  ### Example\n *  ```\n *  <input type=\"number\" [(ngModel)]=\"age\">\n *  ```\n */\n@Directive({\n  selector:\n      'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',\n  host: {\n    '(change)': 'onChange($event.target.value)',\n    '(input)': 'onChange($event.target.value)',\n    '(blur)': 'onTouched()'\n  },\n  providers: [NUMBER_VALUE_ACCESSOR]\n})\nexport class NumberValueAccessor implements ControlValueAccessor {\n  onChange = (_: any) => {};\n  onTouched = () => {};\n\n  constructor(private _renderer: Renderer2, private _elementRef: ElementRef) {}\n\n  writeValue(value: number): void {\n    // The value needs to be normalized for IE9, otherwise it is set to 'null' when null\n    const normalizedValue = value == null ? '' : value;\n    this._renderer.setProperty(this._elementRef.nativeElement, 'value', normalizedValue);\n  }\n\n  registerOnChange(fn: (_: number|null) => void): void {\n    this.onChange = (value) => { fn(value == '' ? null : parseFloat(value)); };\n  }\n  registerOnTouched(fn: () => void): void { this.onTouched = fn; }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {ControlContainer} from './control_container';\nimport {ControlValueAccessor} from './control_value_accessor';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n\nfunction unimplemented(): any {\n  throw new Error('unimplemented');\n}\n\n/**\n * A base class that all control directive extend.\n * It binds a `FormControl` object to a DOM element.\n *\n * Used internally by Angular forms.\n *\n *\n */\nexport abstract class NgControl extends AbstractControlDirective {\n  /** @internal */\n  _parent: ControlContainer|null = null;\n  name: string|null = null;\n  valueAccessor: ControlValueAccessor|null = null;\n  /** @internal */\n  _rawValidators: Array<Validator|ValidatorFn> = [];\n  /** @internal */\n  _rawAsyncValidators: Array<AsyncValidator|AsyncValidatorFn> = [];\n\n  get validator(): ValidatorFn|null { return <ValidatorFn>unimplemented(); }\n  get asyncValidator(): AsyncValidatorFn|null { return <AsyncValidatorFn>unimplemented(); }\n\n  abstract viewToModelUpdate(newValue: any): void;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, Injectable, Injector, Input, OnDestroy, OnInit, Renderer2, forwardRef} from '@angular/core';\n\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\nimport {NgControl} from './ng_control';\n\nexport const RADIO_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => RadioControlValueAccessor),\n  multi: true\n};\n\n/**\n * Internal class used by Angular to uncheck radio buttons with the matching name.\n */\n@Injectable()\nexport class RadioControlRegistry {\n  private _accessors: any[] = [];\n\n  add(control: NgControl, accessor: RadioControlValueAccessor) {\n    this._accessors.push([control, accessor]);\n  }\n\n  remove(accessor: RadioControlValueAccessor) {\n    for (let i = this._accessors.length - 1; i >= 0; --i) {\n      if (this._accessors[i][1] === accessor) {\n        this._accessors.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  select(accessor: RadioControlValueAccessor) {\n    this._accessors.forEach((c) => {\n      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {\n        c[1].fireUncheck(accessor.value);\n      }\n    });\n  }\n\n  private _isSameGroup(\n      controlPair: [NgControl, RadioControlValueAccessor],\n      accessor: RadioControlValueAccessor): boolean {\n    if (!controlPair[0].control) return false;\n    return controlPair[0]._parent === accessor._control._parent &&\n        controlPair[1].name === accessor.name;\n  }\n}\n\n/**\n * @description\n *\n * Writes radio control values and listens to radio control changes.\n *\n * Used by `NgModel`, `FormControlDirective`, and `FormControlName`\n * to keep the view synced with the `FormControl` model.\n *\n * If you have imported the `FormsModule` or the `ReactiveFormsModule`, this\n * value accessor will be active on any radio control that has a form directive. You do\n * **not** need to add a special selector to activate it.\n *\n * ### How to use radio buttons with form directives\n *\n * To use radio buttons in a template-driven form, you'll want to ensure that radio buttons\n * in the same group have the same `name` attribute.  Radio buttons with different `name`\n * attributes do not affect each other.\n *\n * {@example forms/ts/radioButtons/radio_button_example.ts region='TemplateDriven'}\n *\n * When using radio buttons in a reactive form, radio buttons in the same group should have the\n * same `formControlName`. You can also add a `name` attribute, but it's optional.\n *\n * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}\n *\n *  * **npm package**: `@angular/forms`\n *\n *\n */\n@Directive({\n  selector:\n      'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',\n  host: {'(change)': 'onChange()', '(blur)': 'onTouched()'},\n  providers: [RADIO_VALUE_ACCESSOR]\n})\nexport class RadioControlValueAccessor implements ControlValueAccessor,\n    OnDestroy, OnInit {\n  /** @internal */\n  _state: boolean;\n  /** @internal */\n  _control: NgControl;\n  /** @internal */\n  _fn: Function;\n  onChange = () => {};\n  onTouched = () => {};\n\n  @Input() name: string;\n  @Input() formControlName: string;\n  @Input() value: any;\n\n  constructor(\n      private _renderer: Renderer2, private _elementRef: ElementRef,\n      private _registry: RadioControlRegistry, private _injector: Injector) {}\n\n  ngOnInit(): void {\n    this._control = this._injector.get(NgControl);\n    this._checkName();\n    this._registry.add(this._control, this);\n  }\n\n  ngOnDestroy(): void { this._registry.remove(this); }\n\n  writeValue(value: any): void {\n    this._state = value === this.value;\n    this._renderer.setProperty(this._elementRef.nativeElement, 'checked', this._state);\n  }\n\n  registerOnChange(fn: (_: any) => {}): void {\n    this._fn = fn;\n    this.onChange = () => {\n      fn(this.value);\n      this._registry.select(this);\n    };\n  }\n\n  fireUncheck(value: any): void { this.writeValue(value); }\n\n  registerOnTouched(fn: () => {}): void { this.onTouched = fn; }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  }\n\n  private _checkName(): void {\n    if (this.name && this.formControlName && this.name !== this.formControlName) {\n      this._throwNameError();\n    }\n    if (!this.name && this.formControlName) this.name = this.formControlName;\n  }\n\n  private _throwNameError(): void {\n    throw new Error(`\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    `);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, Renderer2, StaticProvider, forwardRef} from '@angular/core';\n\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nexport const RANGE_VALUE_ACCESSOR: StaticProvider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => RangeValueAccessor),\n  multi: true\n};\n\n/**\n * The accessor for writing a range value and listening to changes that is used by the\n * `NgModel`, `FormControlDirective`, and `FormControlName` directives.\n *\n *  ### Example\n *  ```\n *  <input type=\"range\" [(ngModel)]=\"age\" >\n *  ```\n */\n@Directive({\n  selector:\n      'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',\n  host: {\n    '(change)': 'onChange($event.target.value)',\n    '(input)': 'onChange($event.target.value)',\n    '(blur)': 'onTouched()'\n  },\n  providers: [RANGE_VALUE_ACCESSOR]\n})\nexport class RangeValueAccessor implements ControlValueAccessor {\n  onChange = (_: any) => {};\n  onTouched = () => {};\n\n  constructor(private _renderer: Renderer2, private _elementRef: ElementRef) {}\n\n  writeValue(value: any): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'value', parseFloat(value));\n  }\n\n  registerOnChange(fn: (_: number|null) => void): void {\n    this.onChange = (value) => { fn(value == '' ? null : parseFloat(value)); };\n  }\n\n  registerOnTouched(fn: () => void): void { this.onTouched = fn; }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const FormErrorExamples = {\n  formControlName: `\n    <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });`,\n\n  formGroupName: `\n    <div [formGroup]=\"myGroup\">\n       <div formGroupName=\"person\">\n          <input formControlName=\"firstName\">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });`,\n\n  formArrayName: `\n    <div [formGroup]=\"myGroup\">\n      <div formArrayName=\"cities\">\n        <div *ngFor=\"let city of cityArray.controls; index as i\">\n          <input [formControlName]=\"i\">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl('SF')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });`,\n\n  ngModelGroup: `\n    <form>\n       <div ngModelGroup=\"person\">\n          <input [(ngModel)]=\"person.name\" name=\"firstName\">\n       </div>\n    </form>`,\n\n  ngModelWithFormGroup: `\n    <div [formGroup]=\"myGroup\">\n       <input formControlName=\"firstName\">\n       <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n    </div>\n  `\n};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {FormErrorExamples as Examples} from './error_examples';\n\nexport class ReactiveErrors {\n  static controlParentException(): void {\n    throw new Error(\n        `formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${Examples.formControlName}`);\n  }\n\n  static ngModelGroupException(): void {\n    throw new Error(\n        `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        ${Examples.formGroupName}\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        ${Examples.ngModelGroup}`);\n  }\n  static missingFormException(): void {\n    throw new Error(`formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       ${Examples.formControlName}`);\n  }\n\n  static groupParentException(): void {\n    throw new Error(\n        `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${Examples.formGroupName}`);\n  }\n\n  static arrayParentException(): void {\n    throw new Error(\n        `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        ${Examples.formArrayName}`);\n  }\n\n  static disabledAttrWarning(): void {\n    console.warn(`\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    `);\n  }\n\n  static ngModelWarning(directiveName: string): void {\n    console.warn(`\n    It looks like you're using ngModel on the same form field as ${directiveName}. \n    Support for using the ngModel input property and ngModelChange event with \n    reactive form directives has been deprecated in Angular v6 and will be removed \n    in Angular v7.\n    \n    For more information on this, see our API docs here:\n    https://angular.io/api/forms/${directiveName === 'formControl' ? 'FormControlDirective' \n      : 'FormControlName'}#use-with-ngmodel\n    `);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, Host, Input, OnDestroy, Optional, Renderer2, StaticProvider, forwardRef, ÉµlooseIdentical as looseIdentical} from '@angular/core';\n\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nexport const SELECT_VALUE_ACCESSOR: StaticProvider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => SelectControlValueAccessor),\n  multi: true\n};\n\nfunction _buildValueString(id: string | null, value: any): string {\n  if (id == null) return `${value}`;\n  if (value && typeof value === 'object') value = 'Object';\n  return `${id}: ${value}`.slice(0, 50);\n}\n\nfunction _extractId(valueString: string): string {\n  return valueString.split(':')[0];\n}\n\n/**\n * @description\n *\n * Writes values and listens to changes on a select element.\n *\n * Used by `NgModel`, `FormControlDirective`, and `FormControlName`\n * to keep the view synced with the `FormControl` model.\n *\n * If you have imported the `FormsModule` or the `ReactiveFormsModule`, this\n * value accessor will be active on any select control that has a form directive. You do\n * **not** need to add a special selector to activate it.\n *\n * ### How to use select controls with form directives\n *\n * To use a select in a template-driven form, simply add an `ngModel` and a `name`\n * attribute to the main `<select>` tag.\n *\n * If your option values are simple strings, you can bind to the normal `value` property\n * on the option.  If your option values happen to be objects (and you'd like to save the\n * selection in your form as an object), use `ngValue` instead:\n *\n * {@example forms/ts/selectControl/select_control_example.ts region='Component'}\n *\n * In reactive forms, you'll also want to add your form directive (`formControlName` or\n * `formControl`) on the main `<select>` tag. Like in the former example, you have the\n * choice of binding to the  `value` or `ngValue` property on the select's options.\n *\n * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}\n *\n * ### Caveat: Option selection\n *\n * Angular uses object identity to select option. It's possible for the identities of items\n * to change while the data does not. This can happen, for example, if the items are produced\n * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the\n * second response will produce objects with different identities.\n *\n * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.\n * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.\n * If `compareWith` is given, Angular selects option by the return value of the function.\n *\n * #### Syntax\n *\n * ```\n * <select [compareWith]=\"compareFn\"  [(ngModel)]=\"selectedCountries\">\n *     <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\n *         {{country.name}}\n *     </option>\n * </select>\n *\n * compareFn(c1: Country, c2: Country): boolean {\n *     return c1 && c2 ? c1.id === c2.id : c1 === c2;\n * }\n * ```\n *\n * Note: We listen to the 'change' event because 'input' events aren't fired\n * for selects in Firefox and IE:\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350\n * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/\n *\n * * **npm package**: `@angular/forms`\n *\n *\n */\n@Directive({\n  selector:\n      'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',\n  host: {'(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()'},\n  providers: [SELECT_VALUE_ACCESSOR]\n})\nexport class SelectControlValueAccessor implements ControlValueAccessor {\n  value: any;\n  /** @internal */\n  _optionMap: Map<string, any> = new Map<string, any>();\n  /** @internal */\n  _idCounter: number = 0;\n\n  onChange = (_: any) => {};\n  onTouched = () => {};\n\n  @Input()\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    if (typeof fn !== 'function') {\n      throw new Error(`compareWith must be a function, but received ${JSON.stringify(fn)}`);\n    }\n    this._compareWith = fn;\n  }\n\n  private _compareWith: (o1: any, o2: any) => boolean = looseIdentical;\n\n  constructor(private _renderer: Renderer2, private _elementRef: ElementRef) {}\n\n  writeValue(value: any): void {\n    this.value = value;\n    const id: string|null = this._getOptionId(value);\n    if (id == null) {\n      this._renderer.setProperty(this._elementRef.nativeElement, 'selectedIndex', -1);\n    }\n    const valueString = _buildValueString(id, value);\n    this._renderer.setProperty(this._elementRef.nativeElement, 'value', valueString);\n  }\n\n  registerOnChange(fn: (value: any) => any): void {\n    this.onChange = (valueString: string) => {\n      this.value = this._getOptionValue(valueString);\n      fn(this.value);\n    };\n  }\n  registerOnTouched(fn: () => any): void { this.onTouched = fn; }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  }\n\n  /** @internal */\n  _registerOption(): string { return (this._idCounter++).toString(); }\n\n  /** @internal */\n  _getOptionId(value: any): string|null {\n    for (const id of Array.from(this._optionMap.keys())) {\n      if (this._compareWith(this._optionMap.get(id), value)) return id;\n    }\n    return null;\n  }\n\n  /** @internal */\n  _getOptionValue(valueString: string): any {\n    const id: string = _extractId(valueString);\n    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;\n  }\n}\n\n/**\n * @description\n *\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\n *\n * See docs for `SelectControlValueAccessor` for usage examples.\n *\n *\n */\n@Directive({selector: 'option'})\nexport class NgSelectOption implements OnDestroy {\n  id: string;\n\n  constructor(\n      private _element: ElementRef, private _renderer: Renderer2,\n      @Optional() @Host() private _select: SelectControlValueAccessor) {\n    if (this._select) this.id = this._select._registerOption();\n  }\n\n  @Input('ngValue')\n  set ngValue(value: any) {\n    if (this._select == null) return;\n    this._select._optionMap.set(this.id, value);\n    this._setElementValue(_buildValueString(this.id, value));\n    this._select.writeValue(this._select.value);\n  }\n\n  @Input('value')\n  set value(value: any) {\n    this._setElementValue(value);\n    if (this._select) this._select.writeValue(this._select.value);\n  }\n\n  /** @internal */\n  _setElementValue(value: string): void {\n    this._renderer.setProperty(this._element.nativeElement, 'value', value);\n  }\n\n  ngOnDestroy(): void {\n    if (this._select) {\n      this._select._optionMap.delete(this.id);\n      this._select.writeValue(this._select.value);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, ElementRef, Host, Input, OnDestroy, Optional, Renderer2, StaticProvider, forwardRef, ÉµlooseIdentical as looseIdentical} from '@angular/core';\n\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from './control_value_accessor';\n\nexport const SELECT_MULTIPLE_VALUE_ACCESSOR: StaticProvider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),\n  multi: true\n};\n\nfunction _buildValueString(id: string, value: any): string {\n  if (id == null) return `${value}`;\n  if (typeof value === 'string') value = `'${value}'`;\n  if (value && typeof value === 'object') value = 'Object';\n  return `${id}: ${value}`.slice(0, 50);\n}\n\nfunction _extractId(valueString: string): string {\n  return valueString.split(':')[0];\n}\n\n/** Mock interface for HTML Options */\ninterface HTMLOption {\n  value: string;\n  selected: boolean;\n}\n\n/** Mock interface for HTMLCollection */\nabstract class HTMLCollection {\n  length: number;\n  abstract item(_: number): HTMLOption;\n}\n\n/**\n * The accessor for writing a value and listening to changes on a select element.\n *\n *  ### Caveat: Options selection\n *\n * Angular uses object identity to select options. It's possible for the identities of items\n * to change while the data does not. This can happen, for example, if the items are produced\n * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the\n * second response will produce objects with different identities.\n *\n * To customize the default option comparison algorithm, `<select multiple>` supports `compareWith`\n * input. `compareWith` takes a **function** which has two arguments: `option1` and `option2`.\n * If `compareWith` is given, Angular selects options by the return value of the function.\n *\n * #### Syntax\n *\n * ```\n * <select multiple [compareWith]=\"compareFn\"  [(ngModel)]=\"selectedCountries\">\n *     <option *ngFor=\"let country of countries\" [ngValue]=\"country\">\n *         {{country.name}}\n *     </option>\n * </select>\n *\n * compareFn(c1: Country, c2: Country): boolean {\n *     return c1 && c2 ? c1.id === c2.id : c1 === c2;\n * }\n * ```\n *\n *\n */\n@Directive({\n  selector:\n      'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',\n  host: {'(change)': 'onChange($event.target)', '(blur)': 'onTouched()'},\n  providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]\n})\nexport class SelectMultipleControlValueAccessor implements ControlValueAccessor {\n  value: any;\n  /** @internal */\n  _optionMap: Map<string, NgSelectMultipleOption> = new Map<string, NgSelectMultipleOption>();\n  /** @internal */\n  _idCounter: number = 0;\n\n  onChange = (_: any) => {};\n  onTouched = () => {};\n\n  @Input()\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    if (typeof fn !== 'function') {\n      throw new Error(`compareWith must be a function, but received ${JSON.stringify(fn)}`);\n    }\n    this._compareWith = fn;\n  }\n\n  private _compareWith: (o1: any, o2: any) => boolean = looseIdentical;\n\n  constructor(private _renderer: Renderer2, private _elementRef: ElementRef) {}\n\n  writeValue(value: any): void {\n    this.value = value;\n    let optionSelectedStateSetter: (opt: NgSelectMultipleOption, o: any) => void;\n    if (Array.isArray(value)) {\n      // convert values to ids\n      const ids = value.map((v) => this._getOptionId(v));\n      optionSelectedStateSetter = (opt, o) => { opt._setSelected(ids.indexOf(o.toString()) > -1); };\n    } else {\n      optionSelectedStateSetter = (opt, o) => { opt._setSelected(false); };\n    }\n    this._optionMap.forEach(optionSelectedStateSetter);\n  }\n\n  registerOnChange(fn: (value: any) => any): void {\n    this.onChange = (_: any) => {\n      const selected: Array<any> = [];\n      if (_.hasOwnProperty('selectedOptions')) {\n        const options: HTMLCollection = _.selectedOptions;\n        for (let i = 0; i < options.length; i++) {\n          const opt: any = options.item(i);\n          const val: any = this._getOptionValue(opt.value);\n          selected.push(val);\n        }\n      }\n      // Degrade on IE\n      else {\n        const options: HTMLCollection = <HTMLCollection>_.options;\n        for (let i = 0; i < options.length; i++) {\n          const opt: HTMLOption = options.item(i);\n          if (opt.selected) {\n            const val: any = this._getOptionValue(opt.value);\n            selected.push(val);\n          }\n        }\n      }\n      this.value = selected;\n      fn(selected);\n    };\n  }\n  registerOnTouched(fn: () => any): void { this.onTouched = fn; }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  }\n\n  /** @internal */\n  _registerOption(value: NgSelectMultipleOption): string {\n    const id: string = (this._idCounter++).toString();\n    this._optionMap.set(id, value);\n    return id;\n  }\n\n  /** @internal */\n  _getOptionId(value: any): string|null {\n    for (const id of Array.from(this._optionMap.keys())) {\n      if (this._compareWith(this._optionMap.get(id) !._value, value)) return id;\n    }\n    return null;\n  }\n\n  /** @internal */\n  _getOptionValue(valueString: string): any {\n    const id: string = _extractId(valueString);\n    return this._optionMap.has(id) ? this._optionMap.get(id) !._value : valueString;\n  }\n}\n\n/**\n * Marks `<option>` as dynamic, so Angular can be notified when options change.\n *\n * ### Example\n *\n * ```\n * <select multiple name=\"city\" ngModel>\n *   <option *ngFor=\"let c of cities\" [value]=\"c\"></option>\n * </select>\n * ```\n */\n@Directive({selector: 'option'})\nexport class NgSelectMultipleOption implements OnDestroy {\n  id: string;\n  /** @internal */\n  _value: any;\n\n  constructor(\n      private _element: ElementRef, private _renderer: Renderer2,\n      @Optional() @Host() private _select: SelectMultipleControlValueAccessor) {\n    if (this._select) {\n      this.id = this._select._registerOption(this);\n    }\n  }\n\n  @Input('ngValue')\n  set ngValue(value: any) {\n    if (this._select == null) return;\n    this._value = value;\n    this._setElementValue(_buildValueString(this.id, value));\n    this._select.writeValue(this._select.value);\n  }\n\n  @Input('value')\n  set value(value: any) {\n    if (this._select) {\n      this._value = value;\n      this._setElementValue(_buildValueString(this.id, value));\n      this._select.writeValue(this._select.value);\n    } else {\n      this._setElementValue(value);\n    }\n  }\n\n  /** @internal */\n  _setElementValue(value: string): void {\n    this._renderer.setProperty(this._element.nativeElement, 'value', value);\n  }\n\n  /** @internal */\n  _setSelected(selected: boolean) {\n    this._renderer.setProperty(this._element.nativeElement, 'selected', selected);\n  }\n\n  ngOnDestroy(): void {\n    if (this._select) {\n      this._select._optionMap.delete(this.id);\n      this._select.writeValue(this._select.value);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode, ÉµlooseIdentical as looseIdentical} from '@angular/core';\n\nimport {FormArray, FormControl, FormGroup} from '../model';\nimport {Validators} from '../validators';\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {AbstractFormGroupDirective} from './abstract_form_group_directive';\nimport {CheckboxControlValueAccessor} from './checkbox_value_accessor';\nimport {ControlContainer} from './control_container';\nimport {ControlValueAccessor} from './control_value_accessor';\nimport {DefaultValueAccessor} from './default_value_accessor';\nimport {NgControl} from './ng_control';\nimport {normalizeAsyncValidator, normalizeValidator} from './normalize_validator';\nimport {NumberValueAccessor} from './number_value_accessor';\nimport {RadioControlValueAccessor} from './radio_control_value_accessor';\nimport {RangeValueAccessor} from './range_value_accessor';\nimport {FormArrayName} from './reactive_directives/form_group_name';\nimport {ReactiveErrors} from './reactive_errors';\nimport {SelectControlValueAccessor} from './select_control_value_accessor';\nimport {SelectMultipleControlValueAccessor} from './select_multiple_control_value_accessor';\nimport {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n\n\nexport function controlPath(name: string, parent: ControlContainer): string[] {\n  return [...parent.path !, name];\n}\n\nexport function setUpControl(control: FormControl, dir: NgControl): void {\n  if (!control) _throwError(dir, 'Cannot find control with');\n  if (!dir.valueAccessor) _throwError(dir, 'No value accessor for form control with');\n\n  control.validator = Validators.compose([control.validator !, dir.validator]);\n  control.asyncValidator = Validators.composeAsync([control.asyncValidator !, dir.asyncValidator]);\n  dir.valueAccessor !.writeValue(control.value);\n\n  setUpViewChangePipeline(control, dir);\n  setUpModelChangePipeline(control, dir);\n\n  setUpBlurPipeline(control, dir);\n\n  if (dir.valueAccessor !.setDisabledState) {\n    control.registerOnDisabledChange(\n        (isDisabled: boolean) => { dir.valueAccessor !.setDisabledState !(isDisabled); });\n  }\n\n  // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n  dir._rawValidators.forEach((validator: Validator | ValidatorFn) => {\n    if ((<Validator>validator).registerOnValidatorChange)\n      (<Validator>validator).registerOnValidatorChange !(() => control.updateValueAndValidity());\n  });\n\n  dir._rawAsyncValidators.forEach((validator: AsyncValidator | AsyncValidatorFn) => {\n    if ((<Validator>validator).registerOnValidatorChange)\n      (<Validator>validator).registerOnValidatorChange !(() => control.updateValueAndValidity());\n  });\n}\n\nexport function cleanUpControl(control: FormControl, dir: NgControl) {\n  dir.valueAccessor !.registerOnChange(() => _noControlError(dir));\n  dir.valueAccessor !.registerOnTouched(() => _noControlError(dir));\n\n  dir._rawValidators.forEach((validator: any) => {\n    if (validator.registerOnValidatorChange) {\n      validator.registerOnValidatorChange(null);\n    }\n  });\n\n  dir._rawAsyncValidators.forEach((validator: any) => {\n    if (validator.registerOnValidatorChange) {\n      validator.registerOnValidatorChange(null);\n    }\n  });\n\n  if (control) control._clearChangeFns();\n}\n\nfunction setUpViewChangePipeline(control: FormControl, dir: NgControl): void {\n  dir.valueAccessor !.registerOnChange((newValue: any) => {\n    control._pendingValue = newValue;\n    control._pendingChange = true;\n    control._pendingDirty = true;\n\n    if (control.updateOn === 'change') updateControl(control, dir);\n  });\n}\n\nfunction setUpBlurPipeline(control: FormControl, dir: NgControl): void {\n  dir.valueAccessor !.registerOnTouched(() => {\n    control._pendingTouched = true;\n\n    if (control.updateOn === 'blur' && control._pendingChange) updateControl(control, dir);\n    if (control.updateOn !== 'submit') control.markAsTouched();\n  });\n}\n\nfunction updateControl(control: FormControl, dir: NgControl): void {\n  if (control._pendingDirty) control.markAsDirty();\n  control.setValue(control._pendingValue, {emitModelToViewChange: false});\n  dir.viewToModelUpdate(control._pendingValue);\n  control._pendingChange = false;\n}\n\nfunction setUpModelChangePipeline(control: FormControl, dir: NgControl): void {\n  control.registerOnChange((newValue: any, emitModelEvent: boolean) => {\n    // control -> view\n    dir.valueAccessor !.writeValue(newValue);\n\n    // control -> ngModel\n    if (emitModelEvent) dir.viewToModelUpdate(newValue);\n  });\n}\n\nexport function setUpFormContainer(\n    control: FormGroup | FormArray, dir: AbstractFormGroupDirective | FormArrayName) {\n  if (control == null) _throwError(dir, 'Cannot find control with');\n  control.validator = Validators.compose([control.validator, dir.validator]);\n  control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);\n}\n\nfunction _noControlError(dir: NgControl) {\n  return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n}\n\nfunction _throwError(dir: AbstractControlDirective, message: string): void {\n  let messageEnd: string;\n  if (dir.path !.length > 1) {\n    messageEnd = `path: '${dir.path!.join(' -> ')}'`;\n  } else if (dir.path ![0]) {\n    messageEnd = `name: '${dir.path}'`;\n  } else {\n    messageEnd = 'unspecified name attribute';\n  }\n  throw new Error(`${message} ${messageEnd}`);\n}\n\nexport function composeValidators(validators: Array<Validator|Function>): ValidatorFn|null {\n  return validators != null ? Validators.compose(validators.map(normalizeValidator)) : null;\n}\n\nexport function composeAsyncValidators(validators: Array<Validator|Function>): AsyncValidatorFn|\n    null {\n  return validators != null ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) :\n                              null;\n}\n\nexport function isPropertyUpdated(changes: {[key: string]: any}, viewModel: any): boolean {\n  if (!changes.hasOwnProperty('model')) return false;\n  const change = changes['model'];\n\n  if (change.isFirstChange()) return true;\n  return !looseIdentical(viewModel, change.currentValue);\n}\n\nconst BUILTIN_ACCESSORS = [\n  CheckboxControlValueAccessor,\n  RangeValueAccessor,\n  NumberValueAccessor,\n  SelectControlValueAccessor,\n  SelectMultipleControlValueAccessor,\n  RadioControlValueAccessor,\n];\n\nexport function isBuiltInAccessor(valueAccessor: ControlValueAccessor): boolean {\n  return BUILTIN_ACCESSORS.some(a => valueAccessor.constructor === a);\n}\n\nexport function syncPendingControls(form: FormGroup, directives: NgControl[]): void {\n  form._syncPendingControls();\n  directives.forEach(dir => {\n    const control = dir.control as FormControl;\n    if (control.updateOn === 'submit' && control._pendingChange) {\n      dir.viewToModelUpdate(control._pendingValue);\n      control._pendingChange = false;\n    }\n  });\n}\n\n// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented\nexport function selectValueAccessor(\n    dir: NgControl, valueAccessors: ControlValueAccessor[]): ControlValueAccessor|null {\n  if (!valueAccessors) return null;\n\n  if (!Array.isArray(valueAccessors))\n    _throwError(dir, 'Value accessor was not provided as an array for form control with');\n\n  let defaultAccessor: ControlValueAccessor|undefined = undefined;\n  let builtinAccessor: ControlValueAccessor|undefined = undefined;\n  let customAccessor: ControlValueAccessor|undefined = undefined;\n\n  valueAccessors.forEach((v: ControlValueAccessor) => {\n    if (v.constructor === DefaultValueAccessor) {\n      defaultAccessor = v;\n\n    } else if (isBuiltInAccessor(v)) {\n      if (builtinAccessor)\n        _throwError(dir, 'More than one built-in value accessor matches form control with');\n      builtinAccessor = v;\n\n    } else {\n      if (customAccessor)\n        _throwError(dir, 'More than one custom value accessor matches form control with');\n      customAccessor = v;\n    }\n  });\n\n  if (customAccessor) return customAccessor;\n  if (builtinAccessor) return builtinAccessor;\n  if (defaultAccessor) return defaultAccessor;\n\n  _throwError(dir, 'No valid value accessor for form control with');\n  return null;\n}\n\nexport function removeDir<T>(list: T[], el: T): void {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n}\n\n// TODO(kara): remove after deprecation period\nexport function _ngModelWarning(\n    name: string, type: {_ngModelWarningSentOnce: boolean},\n    instance: {_ngModelWarningSent: boolean}, warningConfig: string | null) {\n  if (!isDevMode() || warningConfig === 'never') return;\n\n  if (((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce) ||\n      (warningConfig === 'always' && !instance._ngModelWarningSent)) {\n    ReactiveErrors.ngModelWarning(name);\n    type._ngModelWarningSentOnce = true;\n    instance._ngModelWarningSent = true;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OnDestroy, OnInit} from '@angular/core';\n\nimport {FormGroup} from '../model';\n\nimport {ControlContainer} from './control_container';\nimport {Form} from './form_interface';\nimport {composeAsyncValidators, composeValidators, controlPath} from './shared';\nimport {AsyncValidatorFn, ValidatorFn} from './validators';\n\n\n\n/**\n * This is a base class for code shared between `NgModelGroup` and `FormGroupName`.\n *\n *\n */\nexport class AbstractFormGroupDirective extends ControlContainer implements OnInit, OnDestroy {\n  /** @internal */\n  _parent: ControlContainer;\n\n  /** @internal */\n  _validators: any[];\n\n  /** @internal */\n  _asyncValidators: any[];\n\n  ngOnInit(): void {\n    this._checkParentType();\n    this.formDirective !.addFormGroup(this);\n  }\n\n  ngOnDestroy(): void {\n    if (this.formDirective) {\n      this.formDirective.removeFormGroup(this);\n    }\n  }\n\n  /**\n   * Get the `FormGroup` backing this binding.\n   */\n  get control(): FormGroup { return this.formDirective !.getFormGroup(this); }\n\n  /**\n   * Get the path to this control group.\n   */\n  get path(): string[] { return controlPath(this.name, this._parent); }\n\n  /**\n   * Get the `Form` to which this group belongs.\n   */\n  get formDirective(): Form|null { return this._parent ? this._parent.formDirective : null; }\n\n  get validator(): ValidatorFn|null { return composeValidators(this._validators); }\n\n  get asyncValidator(): AsyncValidatorFn|null {\n    return composeAsyncValidators(this._asyncValidators);\n  }\n\n  /** @internal */\n  _checkParentType(): void {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, Self} from '@angular/core';\n\nimport {AbstractControlDirective} from './abstract_control_directive';\nimport {ControlContainer} from './control_container';\nimport {NgControl} from './ng_control';\n\nexport class AbstractControlStatus {\n  private _cd: AbstractControlDirective;\n\n  constructor(cd: AbstractControlDirective) { this._cd = cd; }\n\n  get ngClassUntouched(): boolean { return this._cd.control ? this._cd.control.untouched : false; }\n  get ngClassTouched(): boolean { return this._cd.control ? this._cd.control.touched : false; }\n  get ngClassPristine(): boolean { return this._cd.control ? this._cd.control.pristine : false; }\n  get ngClassDirty(): boolean { return this._cd.control ? this._cd.control.dirty : false; }\n  get ngClassValid(): boolean { return this._cd.control ? this._cd.control.valid : false; }\n  get ngClassInvalid(): boolean { return this._cd.control ? this._cd.control.invalid : false; }\n  get ngClassPending(): boolean { return this._cd.control ? this._cd.control.pending : false; }\n}\n\nexport const ngControlStatusHost = {\n  '[class.ng-untouched]': 'ngClassUntouched',\n  '[class.ng-touched]': 'ngClassTouched',\n  '[class.ng-pristine]': 'ngClassPristine',\n  '[class.ng-dirty]': 'ngClassDirty',\n  '[class.ng-valid]': 'ngClassValid',\n  '[class.ng-invalid]': 'ngClassInvalid',\n  '[class.ng-pending]': 'ngClassPending',\n};\n\n/**\n * Directive automatically applied to Angular form controls that sets CSS classes\n * based on control status. The following classes are applied as the properties\n * become true:\n *\n * * ng-valid\n * * ng-invalid\n * * ng-pending\n * * ng-pristine\n * * ng-dirty\n * * ng-untouched\n * * ng-touched\n *\n *\n */\n@Directive({selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost})\nexport class NgControlStatus extends AbstractControlStatus {\n  constructor(@Self() cd: NgControl) { super(cd); }\n}\n\n/**\n * Directive automatically applied to Angular form groups that sets CSS classes\n * based on control status (valid/invalid/dirty/etc).\n *\n *\n */\n@Directive({\n  selector:\n      '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',\n  host: ngControlStatusHost\n})\nexport class NgControlStatusGroup extends AbstractControlStatus {\n  constructor(@Self() cd: ControlContainer) { super(cd); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {composeAsyncValidators, composeValidators} from './directives/shared';\nimport {AsyncValidatorFn, ValidationErrors, ValidatorFn} from './directives/validators';\nimport {toObservable} from './validators';\n\n/**\n * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.\n */\nexport const VALID = 'VALID';\n\n/**\n * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.\n */\nexport const INVALID = 'INVALID';\n\n/**\n * Indicates that a FormControl is pending, i.e. that async validation is occurring and\n * errors are not yet available for the input value.\n */\nexport const PENDING = 'PENDING';\n\n/**\n * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor\n * calculations of validity or value.\n */\nexport const DISABLED = 'DISABLED';\n\nfunction _find(control: AbstractControl, path: Array<string|number>| string, delimiter: string) {\n  if (path == null) return null;\n\n  if (!(path instanceof Array)) {\n    path = (<string>path).split(delimiter);\n  }\n  if (path instanceof Array && (path.length === 0)) return null;\n\n  return (<Array<string|number>>path).reduce((v: AbstractControl, name) => {\n    if (v instanceof FormGroup) {\n      return v.controls.hasOwnProperty(name as string) ? v.controls[name] : null;\n    }\n\n    if (v instanceof FormArray) {\n      return v.at(<number>name) || null;\n    }\n\n    return null;\n  }, control);\n}\n\nfunction coerceToValidator(\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null): ValidatorFn|\n    null {\n  const validator =\n      (isOptionsObj(validatorOrOpts) ? (validatorOrOpts as AbstractControlOptions).validators :\n                                       validatorOrOpts) as ValidatorFn |\n      ValidatorFn[] | null;\n\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\n\nfunction coerceToAsyncValidator(\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null, validatorOrOpts?: ValidatorFn |\n        ValidatorFn[] | AbstractControlOptions | null): AsyncValidatorFn|null {\n  const origAsyncValidator =\n      (isOptionsObj(validatorOrOpts) ? (validatorOrOpts as AbstractControlOptions).asyncValidators :\n                                       asyncValidator) as AsyncValidatorFn |\n      AsyncValidatorFn | null;\n\n  return Array.isArray(origAsyncValidator) ? composeAsyncValidators(origAsyncValidator) :\n                                             origAsyncValidator || null;\n}\n\nexport type FormHooks = 'change' | 'blur' | 'submit';\n\n/**\n * @description\n *\n * Interface for options provided to an `AbstractControl`.\n *\n * @experimental\n */\nexport interface AbstractControlOptions {\n  /**\n   * List of validators applied to control.\n   */\n  validators?: ValidatorFn|ValidatorFn[]|null;\n  /**\n   * List of async validators applied to control.\n   */\n  asyncValidators?: AsyncValidatorFn|AsyncValidatorFn[]|null;\n  /**\n   * The event name for control to update upon.\n   */\n  updateOn?: 'change'|'blur'|'submit';\n}\n\n\nfunction isOptionsObj(\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null): boolean {\n  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) &&\n      typeof validatorOrOpts === 'object';\n}\n\n\n/**\n * @description\n *\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n */\nexport abstract class AbstractControl {\n  /** @internal */\n  _pendingDirty: boolean;\n\n  /** @internal */\n  _pendingTouched: boolean;\n\n  /** @internal */\n  _onCollectionChange = () => {};\n\n  /** @internal */\n  _updateOn: FormHooks;\n\n  private _parent: FormGroup|FormArray;\n  private _asyncValidationSubscription: any;\n  public readonly value: any;\n\n  /**\n   * Initialize the AbstractControl instance.\n   * @param validator The function that will determine the synchronous validity of this control.\n   * @param asyncValidator The function that will determine the asynchronous validity of this\n   * control.\n   */\n  constructor(public validator: ValidatorFn|null, public asyncValidator: AsyncValidatorFn|null) {}\n\n  /**\n   * The parent control.\n   */\n  get parent(): FormGroup|FormArray { return this._parent; }\n\n  /**\n   * The validation status of the control. There are four possible\n   * validation statuses:\n   *\n   * * **VALID**:  control has passed all validation checks\n   * * **INVALID**: control has failed at least one validation check\n   * * **PENDING**: control is in the midst of conducting a validation check\n   * * **DISABLED**: control is exempt from validation checks\n   *\n   * These statuses are mutually exclusive, so a control cannot be\n   * both valid AND invalid or invalid AND disabled.\n   */\n  public readonly status: string;\n\n  /**\n   * A control is `valid` when its `status === VALID`.\n   *\n   * In order to have this status, the control must have passed all its\n   * validation checks.\n   */\n  get valid(): boolean { return this.status === VALID; }\n\n  /**\n   * A control is `invalid` when its `status === INVALID`.\n   *\n   * In order to have this status, the control must have failed\n   * at least one of its validation checks.\n   */\n  get invalid(): boolean { return this.status === INVALID; }\n\n  /**\n   * A control is `pending` when its `status === PENDING`.\n   *\n   * In order to have this status, the control must be in the\n   * middle of conducting a validation check.\n   */\n  get pending(): boolean { return this.status == PENDING; }\n\n  /**\n   * A control is `disabled` when its `status === DISABLED`.\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   */\n  get disabled(): boolean { return this.status === DISABLED; }\n\n  /**\n   * A control is `enabled` as long as its `status !== DISABLED`.\n   *\n   * In other words, it has a status of `VALID`, `INVALID`, or\n   * `PENDING`.\n   */\n  get enabled(): boolean { return this.status !== DISABLED; }\n\n  /**\n   * Returns